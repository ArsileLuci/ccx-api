use rust_decimal::Decimal;
use url::Url;

use crate::api::Api;
use crate::error::LibResult;
use crate::types::buyer::Buyer;
use crate::types::enums::TerminalType;
use crate::types::goods::OrderGoods;
use crate::types::merchant::Merchant;
use crate::types::order_env::OrderEnv;
use crate::types::shipping::Shipping;
use crate::types::time::Time;
use crate::uuid_simple;
use crate::BinancePayResponse;

const V2_BINANCEPAY_OPENAPI_ORDER: &str = "/binancepay/openapi/v2/order";

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct V2CreateOrderRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub merchant: Option<Merchant>,
    #[serde(rename = "env")]
    pub order_env: OrderEnv,
    #[serde(rename = "merchantTradeNo", with = "uuid_simple")]
    pub merchant_trade_no: uuid::Uuid,
    #[serde(rename = "orderAmount")]
    pub order_amount: Decimal,
    pub currency: String,
    pub goods: OrderGoods,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shipping: Option<Shipping>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub buyer: Option<Buyer>,
    #[serde(rename = "returnUrl")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub return_url: Option<Url>,
    #[serde(rename = "cancelUrl")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cancel_url: Option<Url>,
    #[serde(rename = "orderExpireTime")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub order_expire_time: Option<i64>,
    #[serde(rename = "supportPayCurrency")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub support_pay_currency: Option<String>,
    #[serde(rename = "appId")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_id: Option<String>,
    #[serde(rename = "universalUrlAttach")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub universal_url_attach: Option<Url>,
    #[serde(rename = "passThroughInfo")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pass_through_info: Option<String>,
    #[serde(rename = "webhookUrl")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub webhook_url: Option<Url>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct V2OrderResult {
    // prepayId	string(19]	Y	-	unique id generated by binance
    #[serde(rename = "prepayId")]
    pub prepay_id: String,
    // terminalType	string(20]	Y		same as terminalType in request data
    #[serde(rename = "terminalType")]
    pub terminal_type: TerminalType,
    // expireTime	long	Y	-	expire time in milli seconds
    #[serde(rename = "expireTime")]
    pub expire_time: i64,
    // qrcodeLink	string(256]	Y	-	qr code img link
    #[serde(rename = "qrcodeLink")]
    pub qrcode_link: String,
    // qrContent	string(256]	Y	-	qr contend info
    #[serde(rename = "qrContent")]
    pub qr_content: String,
    // checkoutUrl	string(256]	Y	-	binance hosted checkout page url
    #[serde(rename = "checkoutUrl")]
    pub checkout_url: String,
    // deeplink	string(256]	Y	-	deeplink to open binance app to finish payment
    #[serde(rename = "deeplink")]
    pub deeplink: String,
    // universalUrl	string	Y	maximum length 512	universal url to finish the payment
    #[serde(rename = "universalUrl")]
    pub universal_url: String,
    // currency	string	Y	-	order currency
    pub currency: String,
    // totalFee decimal(.8)	Y	-	order total amount
    #[serde(rename = "totalFee")]
    pub total_fee: Decimal,
    // iatCurrency	string	N	-	order fiat currency, only return when create in fiat
    #[serde(default, rename = "fiatCurrency")]
    pub fiat_currency: Option<String>,
    // fiatAmount	decimal(.8)	N	-	order fiat amount ,only return when create in fiat
    #[serde(default, rename = "fiatAmount")]
    pub fiat_amount: Option<Decimal>,
}

impl<S: crate::client::BinancePaySigner> Api<S> {
    pub async fn v2_create_order(
        &self,
        request: V2CreateOrderRequest,
        time_window: impl Into<Time>,
    ) -> LibResult<BinancePayResponse<V2OrderResult>> {
        self.client
            .post_json(V2_BINANCEPAY_OPENAPI_ORDER, request)?
            .signed(time_window)?
            .random_nonce()?
            .send()
            .await
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_serde_create_order_request() {
        let example = r#"
        {
            "env" : {
              "terminalType": "APP"
            },
            "merchantTradeNo": "2f4b0696-e691-43b5-94bb-ee4e4752d068",
            "orderAmount": 25.17,
            "currency": "BUSD",
            "goods" : {
              "goodsType": "01",
              "goodsCategory": "D000",
              "referenceGoodsId": "2f4b0696-e691-43b5-94bb-ee4e4752d068",
              "goodsName": "Ice Cream",
              "goodsDetail": "Greentea ice cream cone"
            }
        }
        "#;
        let response: V2CreateOrderRequest =
            serde_json::from_str(example).expect("Failed from_str");
        println!(
            "test_serde_create_order_request response :: {:#?}",
            response
        );
    }

    #[test]
    fn test_serde_create_order_response() {
        let example = r#"
        {
            "status": "SUCCESS",
            "code": "000000",
            "data": {
              "prepayId": "29383937493038367292",
              "terminalType": "APP",
              "expireTime": 121123232223,
              "qrcodeLink": "https://qrservice.dev.com/en/qr/dplkb005181944f84b84aba2430e1177012b.jpg",
              "qrContent": "https://qrservice.dev.com/en/qr/dplk12121112b",
              "checkoutUrl": "https://pay.binance.com/checkout/dplk12121112b",
              "deeplink": "bnc://app.binance.com/payment/secpay/xxxxxx",
              "universalUrl": "https://app.binance.com/payment/secpay?_dp=xxx=&linkToken=xxx",
              "totalFee": "25.17",
              "currency": "USDT"
            },
            "errorMessage": ""
        }
        "#;
        let response: BinancePayResponse<V2OrderResult> =
            serde_json::from_str(example).expect("Failed from_str");
        println!(
            "test_serde_create_order_response response :: {:#?}",
            response
        );
    }
}
